#!/bin/bash

# Defines all constants.
UPDATE_TIME=10
SAVE_PATH=~/git/Project-I.A.N./Testing
DATABASE=$SAVE_PATH/test.db
COMMAND="ps -u $USER -o "%p///%c///" -o cmd --no-headers"
BREAK_STRING="///"

# Defines all global data stores.
declare -A open_program_dict

# Checks the path for the program exists.
if [ ! -d $SAVE_PATH ]; then
    mkdir $SAVE_PATH
fi

# Checks that the database has been created.
if [ ! -f $DATABASE ]; then
    sqlite3 $DATABASE < create.sql
fi

# Checks that there is a latest time file for use when updating the database.
if [ ! -f $SAVE_PATH/latest_time ]; then
    echo 0 >latest_time
fi

# Creates a close log for all programs if the main program is terminated.
function exit_trap_cleanup () {
    current_time=$(date +"%s")

    for pid in "${!open_program_dict[@]}"; do
        name=${open_program_dict[$pid]}
        # Remove any unwanted white space.
        name=$( echo "$name" | awk '{gsub(/^ +| +$/,"")} {print $0}' )
        pid=$( echo "$pid" | awk '{gsub(/^ +| +$/,"")} {print $0}' )

        echo $( sqlite3 $DATABASE "
            INSERT INTO ProgramLogs(ProgramName, PID, DateTime, OpenClose)
            VALUES('$name', '$pid', '$current_time', 'Close');" )
    done
    # Updates the database.
    ./textdatarunnerdb
}

trap exit_trap_cleanup EXIT

function compare_output () {
    integers=(1 2 3)
    mapfile -t prev_output < $SAVE_PATH/previous_output 
    mapfile -t new_output < $SAVE_PATH/newest_output 
    offset=0
    local -a log

    for row_number in ${!new_output[@]}; do

        if echo "${new_output[$row_number]}" | grep "$COMMAND"; then
            continue
        fi

        prev_record=()
        new_record=()

        if [[ $( grep -o "$BREAK_STRING" <<< "${new_output[$row_number]}" | wc -l ) -ne  "2" ]]; then
            continue
        fi
        
        for i in "${integers[@]}"; do
            prev_record+=( $( echo ${prev_output[ $(( row_number + offset )) ]} | awk -F'///' -v i=$i '{print $i}' ) )
            new_record+=( $( echo ${new_output[ $row_number ]} | awk -F'///' -v i=$i '{print $i}' ) )
        done

        while true; do

            if [[ "$prev_record" == "$new_record" ]]; then
                break

            else
                local -i prev_pid=${prev_record[0]} 

                if [ "$prev_pid" -eq "0" ] || [ -z "$prev_pid" ]; then
                    prev_pid=$(( $( cat /proc/sys/kernel/pid_max ) + 1 ))
                fi

                local -i new_pid=${new_record[0]}

                if [ "$new_pid" -lt "$prev_pid" ]; then
                    (( offset-- ))
                    log=( "${log[@]}" "${new_output[ $(( row_number )) ]} ///$( date +"%s" ) ///Open" )
                    break

                elif [ "$new_pid" -gt "$prev_pid" ]; then

                    if ! echo "${new_output[$row_number]}" | grep "$COMMAND"; then
                        log=( "${log[@]}" "${prev_output[ $(( row_number + offset )) ]} ///$(date +"%s") ///Close" )
                    fi

                    offset=$(( offset + 1 )) #(( offset++ ))
                    prev_record=()
                    for i in "${integers[@]}"; do
                        prev_record+=( $( echo ${prev_output[ $(( row_number + offset )) ]} | awk -F'///' -v i=$i '{print $i}' ) )
                    done
                fi
            fi
        done
    done

    echo c1

    for index in "${!prev_output[@]:$((row_number + offset + 1))}"; do

        if echo "${prev_output[$index]}" | grep "$COMMAND"; then
            continue
        else
            log=( "${log[@]}" "${prev_output[$index]} ///$(date +"%s") ///Close" )
        fi
    done

    integers+=(4 5)

    echo "-----LOGS-----"
    for i in "${log[@]}"; do
        echo $i
    done
    echo "-----LOGS-----"

    record=()

    for item in "${!log[@]}"; do
        unset present

        if echo "${log[$item]}" | grep "$COMMAND"; then
            unset log[$item]
            continue
        fi

        for i in "${integers[@]}"; do
            record+=( $( echo ${log[ $item ]} | awk -F'///' -v i=$i '{print $i}' ) )
        done

        log_name=${record[1]}
        log_name=$( echo "$log_name" | awk '{gsub(/^ +| +$/,"")} {print $0}' )
        log_pid=${record[1]}
        log_pid=$( echo "$log_pid" | awk '{gsub(/^ +| +$/,"")} {print $0}' )

        for pid in "${!open_program_dict[@]}"; do
            pname=${open_program_dict["$pid"]}

            if [[ "$pname" == "$log_name" ]]; then
                local present=true

                if [[ "$log_pid" == "$pid" ]]; then
                    unset open_program_dict["$pid"]

                else
                    unset log[$item]
                fi

                break
            fi
        done

        if ! [ $present ]; then

            if [[ "${record[-1]}" == "Open" ]]; then
                open_program_dict["$log_pid"]="$log_name"

            else
                unset log[$item]
            fi
        else
            unset present
        fi
    done

    echo c2

    echo "~~~~~LOGS~~~~~"
    for i in "${log[@]}"; do
        echo $i
    done
    echo "~~~~~LOGS~~~~~"

    for index in "${!log[@]}"; do
        record=()

        for i in "${integers[@]}"; do
            record+=( $( echo ${log[$index]} | awk -F'///' -v i=$i '{print $i}' ) )
        done

        pid=${record[0]}
        name=${record[1]}
        name=$( echo "$name" | awk '{gsub(/^ +| +$/,"")} {print $0}' )
        pid=$( echo "$pid" | awk '{gsub(/^ +| +$/,"")} {print $0}' )
        command=${record[@]:2:${#record[@]}-2}
        current_time=${record[-2]}
        state=${record[-1]}

        programs=$( sqlite3 $DATABASE "
            SELECT Programs.ProgramName
            FROM Programs;" )

        if ! [[ "${programs[*]}" == *"$name"* ]]; then

            echo $( sqlite3 $DATABASE "
                INSERT INTO Programs(ProgramName, TimesRun, TotalRunTime)
                VALUES('$name', 0, 0);" )
        fi

        echo logging $name, $pid, $current_time, $state
        
        echo $( sqlite3 $DATABASE "
            INSERT INTO ProgramLogs(ProgramName, PID, DateTime, OpenClose)
            VALUES('$name', '$pid', '$current_time', '$state');" )
    done

    echo c3
}

$COMMAND > $SAVE_PATH/previous_output

# Loops indefinitely.
while true; do
    echo ~~~
    # Gets the currently running processes.
    $COMMAND > $SAVE_PATH/newest_output
    compare_output # The function call for the main computation.

    if [ -f $SAVE_PATH/open_programs ]; then
        rm $SAVE_PATH/open_programs
    fi

    for pid in "${!open_program_dict[@]}"; do
        echo \'${open_program_dict["$pid"]}\' \"$pid\" >>open_programs
    done

    sleep $UPDATE_TIME # The delay between updates.
    cat $SAVE_PATH/newest_output > $SAVE_PATH/previous_output # Re-writes the newest and previous files.
done
